[ { "BlackBox" :
    { "name"      : "GHC.Prim.quotRemInt#"
    , "kind"      : "Declaration"
    , "type"      : "quotRemInt# :: Int# -> Int# -> (#Int#, Int##)"
    , "template"  :
"// quotRemInt begin
~SIGD[~GENSYM[quot_res][0]][0];
~SIGD[~GENSYM[rem_res][1]][0];
assign ~SYM[0] = ~ARG[0] / ~ARG[1];
assign ~SYM[1] = ~ARG[0] % ~ARG[1];

assign ~RESULT = {~SYM[0],~SYM[1]};
// quotRemInt end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.quotRemWord#"
    , "kind"      : "Declaration"
    , "type"      : "quotRemWord# :: Word# -> Word# -> (#Word#, Word##)"
    , "template"  :
"// quotRemWord begin
~SIGD[~GENSYM[quot_res][0]][0];
~SIGD[~GENSYM[rem_res][1]][0];
assign ~SYM[0] = ~ARG[0] / ~ARG[1];
assign ~SYM[1] = ~ARG[0] % ~ARG[1];

assign ~RESULT = {~SYM[0],~SYM[1]};
// quotRemWord end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt8#"
    , "kind"      : "Declaration"
    , "type"      : "popCnt8# :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "depth2Index"
        , "extension" : "inc"
        , "template" :
"// given a level and a depth, calculate the corresponding index into the
// intermediate array
function integer ~INCLUDENAME[0];
  input integer levels;
  input integer depth;

  ~INCLUDENAME[0] = (2 ** levels) - (2 ** depth);
endfunction"
        }
      ]
    , "template" :
"// popCnt8 begin
localparam ~GENSYM[width][0] = 8;

// depth of the tree
localparam ~GENSYM[levels][2] = $clog2(~SYM[0]);

logic [~SYM[2]:0] ~GENSYM[intermediate][3] [0:(2*~SYM[0])-2];

// put input into the first half of the intermediate array
genvar ~GENSYM[i][4];
~GENERATE
for (~SYM[4] = 0; ~SYM[4] < ~SYM[0]; ~SYM[4]=~SYM[4]+1) begin : ~GENSYM[mk_array][11]
  assign ~SYM[3][~SYM[4]] = $unsigned(~VAR[input][0][~SYM[4]]);
end
~ENDGENERATE

// Create the tree of instantiated components
genvar ~GENSYM[d][6];
genvar ~GENSYM[i][7];
~GENERATE
if (~SYM[2] != 0) begin : ~GENSYM[make_tree][8]
  for (~SYM[6] = (~SYM[2] - 1); ~SYM[6] >= 0; ~SYM[6]=~SYM[6]-1) begin : ~GENSYM[tree_depth][9]
    for (~SYM[7] = 0; ~SYM[7] < (2**~SYM[6]); ~SYM[7] = ~SYM[7]+1) begin : ~GENSYM[tree_depth_loop][10]
      assign ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+~SYM[7]] =
             ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+2)+(2*~SYM[7])] +
             ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+2)+(2*~SYM[7])+1];
    end
  end
end
~ENDGENERATE

// The last element of the intermediate array holds the result
assign ~RESULT = $unsigned(~SYM[3][(2*~SYM[0])-2]);
// popCnt8 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt16#"
    , "kind"      : "Declaration"
    , "type"      : "popCnt16# :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "depth2Index"
        , "extension" : "inc"
        , "template" :
"// given a level and a depth, calculate the corresponding index into the
// intermediate array
function integer ~INCLUDENAME[0];
  input integer levels;
  input integer depth;

  ~INCLUDENAME[0] = (2 ** levels) - (2 ** depth);
endfunction"
        }
      ]
    , "template" :
"// popCnt16 begin
localparam ~GENSYM[width][0] = 16;

// depth of the tree
localparam ~GENSYM[levels][2] = $clog2(~SYM[0]);

logic [~SYM[2]:0] ~GENSYM[intermediate][3] [0:(2*~SYM[0])-2];

// put input into the first half of the intermediate array
genvar ~GENSYM[i][4];
~GENERATE
for (~SYM[4] = 0; ~SYM[4] < ~SYM[0]; ~SYM[4]=~SYM[4]+1) begin : ~GENSYM[mk_array][11]
  assign ~SYM[3][~SYM[4]] = $unsigned(~VAR[input][0][~SYM[4]]);
end
~ENDGENERATE

// Create the tree of instantiated components
genvar ~GENSYM[d][6];
genvar ~GENSYM[i][7];
~GENERATE
if (~SYM[2] != 0) begin : ~GENSYM[make_tree][8]
  for (~SYM[6] = (~SYM[2] - 1); ~SYM[6] >= 0; ~SYM[6]=~SYM[6]-1) begin : ~GENSYM[tree_depth][9]
    for (~SYM[7] = 0; ~SYM[7] < (2**~SYM[6]); ~SYM[7] = ~SYM[7]+1) begin : ~GENSYM[tree_depth_loop][10]
      assign ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+~SYM[7]] =
             ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+2)+(2*~SYM[7])] +
             ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+2)+(2*~SYM[7])+1];
    end
  end
end
~ENDGENERATE

// The last element of the intermediate array holds the result
assign ~RESULT = $unsigned(~SYM[3][(2*~SYM[0])-2]);
// popCnt16 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt32#"
    , "kind"      : "Declaration"
    , "type"      : "popCnt32# :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "depth2Index"
        , "extension" : "inc"
        , "template" :
"// given a level and a depth, calculate the corresponding index into the
// intermediate array
function integer ~INCLUDENAME[0];
  input integer levels;
  input integer depth;

  ~INCLUDENAME[0] = (2 ** levels) - (2 ** depth);
endfunction"
        }
      ]
    , "template" :
"// popCnt32 begin
localparam ~GENSYM[width][0] = 32;

// depth of the tree
localparam ~GENSYM[levels][2] = $clog2(~SYM[0]);

logic [~SYM[2]:0] ~GENSYM[intermediate][3] [0:(2*~SYM[0])-2];

// put input into the first half of the intermediate array
genvar ~GENSYM[i][4];
~GENERATE
for (~SYM[4] = 0; ~SYM[4] < ~SYM[0]; ~SYM[4]=~SYM[4]+1) begin : ~GENSYM[mk_array][11]
  assign ~SYM[3][~SYM[4]] = $unsigned(~VAR[input][0][~SYM[4]]);
end
~ENDGENERATE

// Create the tree of instantiated components
genvar ~GENSYM[d][6];
genvar ~GENSYM[i][7];
~GENERATE
if (~SYM[2] != 0) begin : ~GENSYM[make_tree][8]
  for (~SYM[6] = (~SYM[2] - 1); ~SYM[6] >= 0; ~SYM[6]=~SYM[6]-1) begin : ~GENSYM[tree_depth][9]
    for (~SYM[7] = 0; ~SYM[7] < (2**~SYM[6]); ~SYM[7] = ~SYM[7]+1) begin : ~GENSYM[tree_depth_loop][10]
      assign ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+~SYM[7]] =
             ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+2)+(2*~SYM[7])] +
             ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+2)+(2*~SYM[7])+1];
    end
  end
end
~ENDGENERATE

// The last element of the intermediate array holds the result
assign ~RESULT = $unsigned(~SYM[3][(2*~SYM[0])-2]);
// popCnt32 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt64#"
    , "kind"      : "Declaration"
    , "type"      : "popCnt64# :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "depth2Index"
        , "extension" : "inc"
        , "template" :
"// given a level and a depth, calculate the corresponding index into the
// intermediate array
function integer ~INCLUDENAME[0];
  input integer levels;
  input integer depth;

  ~INCLUDENAME[0] = (2 ** levels) - (2 ** depth);
endfunction"
        }
      ]
    , "template" :
"// popCnt64 begin
localparam ~GENSYM[width][0] = 64;

// depth of the tree
localparam ~GENSYM[levels][2] = $clog2(~SYM[0]);

logic [~SYM[2]:0] ~GENSYM[intermediate][3] [0:(2*~SYM[0])-2];

// put input into the first half of the intermediate array
genvar ~GENSYM[i][4];
~GENERATE
for (~SYM[4] = 0; ~SYM[4] < ~SYM[0]; ~SYM[4]=~SYM[4]+1) begin : ~GENSYM[mk_array][11]
  assign ~SYM[3][~SYM[4]] = $unsigned(~VAR[input][0][~SYM[4]]);
end
~ENDGENERATE

// Create the tree of instantiated components
genvar ~GENSYM[d][6];
genvar ~GENSYM[i][7];
~GENERATE
if (~SYM[2] != 0) begin : ~GENSYM[make_tree][8]
  for (~SYM[6] = (~SYM[2] - 1); ~SYM[6] >= 0; ~SYM[6]=~SYM[6]-1) begin : ~GENSYM[tree_depth][9]
    for (~SYM[7] = 0; ~SYM[7] < (2**~SYM[6]); ~SYM[7] = ~SYM[7]+1) begin : ~GENSYM[tree_depth_loop][10]
      assign ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+~SYM[7]] =
             ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+2)+(2*~SYM[7])] +
             ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+2)+(2*~SYM[7])+1];
    end
  end
end
~ENDGENERATE

// The last element of the intermediate array holds the result
assign ~RESULT = $unsigned(~SYM[3][(2*~SYM[0])-2]);
// popCnt64 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.popCnt#"
    , "kind"      : "Declaration"
    , "type"      : "popCnt# :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "depth2Index"
        , "extension" : "inc"
        , "template" :
"// given a level and a depth, calculate the corresponding index into the
// intermediate array
function integer ~INCLUDENAME[0];
  input integer levels;
  input integer depth;

  ~INCLUDENAME[0] = (2 ** levels) - (2 ** depth);
endfunction"
        }
      ]
    , "template" :
"// popCnt begin
localparam ~GENSYM[width][0] = ~SIZE[~TYPO];

// depth of the tree
localparam ~GENSYM[levels][2] = $clog2(~SYM[0]);

logic [~SYM[2]:0] ~GENSYM[intermediate][3] [0:(2*~SYM[0])-2];

// put input into the first half of the intermediate array
genvar ~GENSYM[i][4];
~GENERATE
for (~SYM[4] = 0; ~SYM[4] < ~SYM[0]; ~SYM[4]=~SYM[4]+1) begin : ~GENSYM[mk_array][11]
  assign ~SYM[3][~SYM[4]] = $unsigned(~VAR[input][0][~SYM[4]]);
end
~ENDGENERATE

// Create the tree of instantiated components
genvar ~GENSYM[d][6];
genvar ~GENSYM[i][7];
~GENERATE
if (~SYM[2] != 0) begin : ~GENSYM[make_tree][8]
  for (~SYM[6] = (~SYM[2] - 1); ~SYM[6] >= 0; ~SYM[6]=~SYM[6]-1) begin : ~GENSYM[tree_depth][9]
    for (~SYM[7] = 0; ~SYM[7] < (2**~SYM[6]); ~SYM[7] = ~SYM[7]+1) begin : ~GENSYM[tree_depth_loop][10]
      assign ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+1)+~SYM[7]] =
             ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+2)+(2*~SYM[7])] +
             ~SYM[3][~INCLUDENAME[0](~SYM[2]+1,~SYM[6]+2)+(2*~SYM[7])+1];
    end
  end
end
~ENDGENERATE

// The last element of the intermediate array holds the result
assign ~RESULT = $unsigned(~SYM[3][(2*~SYM[0])-2]);
// popCnt end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz8#"
    , "kind"      : "Declaration"
    , "type"      : "clz8 :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "enc"
        , "extension" : "inc"
        , "template" :
"function [1:0] ~INCLUDENAME[0];
  input [1:0] a;
  case (a)
    2'b00:   ~INCLUDENAME[0] = 2'b10;
    2'b01:   ~INCLUDENAME[0] = 2'b01;
    2'b10:   ~INCLUDENAME[0] = 2'b00;
    default: ~INCLUDENAME[0] = 2'b00;
  endcase
endfunction"
        }
      ]
    , "template" :
"// clz8 begin
logic [0:7] ~GENSYM[v][1];
assign ~SYM[1] = ~ARG[0][7:0];

logic [0:7] ~GENSYM[e][2];
genvar ~GENSYM[n][3];
~GENERATE
for (~SYM[3]=0;~SYM[3]<4;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
  assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
end
~ENDGENERATE

logic [0:5] ~GENSYM[a][4];
genvar ~GENSYM[i1][5];
~GENERATE
for (~SYM[5]=0;~SYM[5]<2;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage1][6]
  localparam n = 2;
  logic [3:0] i;
  assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:3] ~GENSYM[res][7];
~GENERATE
if (1) begin
localparam n = 3;
logic [5:0] i;
assign i = ~SYM[4][0:5];
always_comb begin
  case (i[n-1+n])
    1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(~SYM[7]);
// clz8 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz16#"
    , "kind"      : "Declaration"
    , "type"      : "clz16 :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "enc"
        , "extension" : "inc"
        , "template" :
"function [1:0] ~INCLUDENAME[0];
  input [1:0] a;
  case (a)
    2'b00:   ~INCLUDENAME[0] = 2'b10;
    2'b01:   ~INCLUDENAME[0] = 2'b01;
    2'b10:   ~INCLUDENAME[0] = 2'b00;
    default: ~INCLUDENAME[0] = 2'b00;
  endcase
endfunction"
        }
      ]
    , "template" :
"// clz16 begin
logic [0:15] ~GENSYM[v][1];
assign ~SYM[1] = ~ARG[0][15:0];

logic [0:15] ~GENSYM[e][2];
genvar ~GENSYM[i][3];
~GENERATE
for (~SYM[3]=0;~SYM[3]<8;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
  assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
end
~ENDGENERATE

logic [0:11] ~GENSYM[a][4];
genvar ~GENSYM[i1][5];
~GENERATE
for (~SYM[5]=0;~SYM[5]<4;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
  localparam n = 2;
  logic [3:0] i;
  assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:7] ~GENSYM[b][9];
genvar ~GENSYM[i2][10];
~GENERATE
for (~SYM[10]=0;~SYM[10]<2;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
  localparam n = 3;
  logic [5:0] i;
  assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:4] ~GENSYM[res][7];
~GENERATE
if (1) begin
localparam n = 4;
logic [7:0] i;
assign i = ~SYM[9][0:7];
always_comb begin
  case (i[n-1+n])
    1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(~SYM[7]);
// clz16 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz32#"
    , "kind"      : "Declaration"
    , "type"      : "clz32 :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "enc"
        , "extension" : "inc"
        , "template" :
"function [1:0] ~INCLUDENAME[0];
  input [1:0] a;
  case (a)
    2'b00:   ~INCLUDENAME[0] = 2'b10;
    2'b01:   ~INCLUDENAME[0] = 2'b01;
    2'b10:   ~INCLUDENAME[0] = 2'b00;
    default: ~INCLUDENAME[0] = 2'b00;
  endcase
endfunction"
        }
      ]
    , "template" :
"// clz32 begin
logic [0:31] ~GENSYM[v][1];
assign ~SYM[1] = ~ARG[0][31:0];

logic [0:31] ~GENSYM[e][2];
genvar ~GENSYM[i][3];
~GENERATE
for (~SYM[3]=0;~SYM[3]<16;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
  assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
end
~ENDGENERATE

logic [0:23] ~GENSYM[a][4];
genvar ~GENSYM[i1][5];
~GENERATE
for (~SYM[5]=0;~SYM[5]<8;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
  localparam n = 2;
  logic [3:0] i;
  assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:15] ~GENSYM[b][9];
genvar ~GENSYM[i2][10];
~GENERATE
for (~SYM[10]=0;~SYM[10]<4;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
  localparam n = 3;
  logic [5:0] i;
  assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:9] ~GENSYM[c][12];
genvar ~GENSYM[i3][13];
~GENERATE
for (~SYM[13]=0;~SYM[13]<2;~SYM[13]=~SYM[13]+1) begin : ~GENSYM[mux_stage3][14]
  localparam n = 4;
  logic [7:0] i;
  assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:5] ~GENSYM[res][7];
~GENERATE
if (1) begin
localparam n = 5;
logic [9:0] i;
assign i = ~SYM[12][0:9];
always_comb begin
  case (i[n-1+n])
    1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(~SYM[7]);
// clz32 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz64#"
    , "kind"      : "Declaration"
    , "type"      : "clz64 :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "enc"
        , "extension" : "inc"
        , "template" :
"function [1:0] ~INCLUDENAME[0];
  input [1:0] a;
  case (a)
    2'b00:   ~INCLUDENAME[0] = 2'b10;
    2'b01:   ~INCLUDENAME[0] = 2'b01;
    2'b10:   ~INCLUDENAME[0] = 2'b00;
    default: ~INCLUDENAME[0] = 2'b00;
  endcase
endfunction"
        }
      ]
    , "template" :
"// clz64 begin
logic [0:63] ~GENSYM[v][1];
assign ~SYM[1] = ~ARG[0][63:0];

logic [0:63] ~GENSYM[e][2];
genvar ~GENSYM[i][3];
~GENERATE
for (~SYM[3]=0;~SYM[3]<32;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
  assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
end
~ENDGENERATE

logic [0:47] ~GENSYM[a][4];
genvar ~GENSYM[i1][5];
~GENERATE
for (~SYM[5]=0;~SYM[5]<16;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
  localparam n = 2;
  logic [3:0] i;
  assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:31] ~GENSYM[b][9];
genvar ~GENSYM[i2][10];
~GENERATE
for (~SYM[10]=0;~SYM[10]<8;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
  localparam n = 3;
  logic [5:0] i;
  assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:19] ~GENSYM[c][12];
genvar ~GENSYM[i3][13];
~GENERATE
for (~SYM[13]=0;~SYM[13]<4;~SYM[13]=~SYM[13]+1) begin : ~GENSYM[mux_stage3][14]
  localparam n = 4;
  logic [7:0] i;
  assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:11] ~GENSYM[d][15];
genvar ~GENSYM[i4][16];
~GENERATE
for (~SYM[16]=0;~SYM[16]<2;~SYM[16]=~SYM[16]+1) begin : ~GENSYM[mux_stage4][17]
  localparam n = 5;
  logic [9:0] i;
  assign i = ~SYM[12][~SYM[16]*10:~SYM[16]*10+9];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:6] ~GENSYM[res][7];
~GENERATE
if (1) begin
localparam n = 6;
logic [11:0] i;
assign i = ~SYM[15][0:11];
always_comb begin
  case (i[n-1+n])
    1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(~SYM[7]);
// clz64 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.clz#"
    , "kind"      : "Declaration"
    , "type"      : "clz :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "enc"
        , "extension" : "inc"
        , "template" :
"function [1:0] ~INCLUDENAME[0];
  input [1:0] a;
  case (a)
    2'b00:   ~INCLUDENAME[0] = 2'b10;
    2'b01:   ~INCLUDENAME[0] = 2'b01;
    2'b10:   ~INCLUDENAME[0] = 2'b00;
    default: ~INCLUDENAME[0] = 2'b00;
  endcase
endfunction"
        }
      ]
    , "template" :
"// clz begin
~IF ~IW64 ~THEN
logic [0:63] ~GENSYM[v][1];
assign ~SYM[1] = ~ARG[0][63:0];

logic [0:63] ~GENSYM[e][2];
genvar ~GENSYM[i][3];
~GENERATE
for (~SYM[3]=0;~SYM[3]<32;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
  assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
end
~ENDGENERATE

logic [0:47] ~GENSYM[a][4];
genvar ~GENSYM[i1][5];
~GENERATE
for (~SYM[5]=0;~SYM[5]<16;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
  localparam n = 2;
  logic [3:0] i;
  assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:31] ~GENSYM[b][9];
genvar ~GENSYM[i2][10];
~GENERATE
for (~SYM[10]=0;~SYM[10]<8;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
  localparam n = 3;
  logic [5:0] i;
  assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:19] ~GENSYM[c][12];
genvar ~GENSYM[i3][13];
~GENERATE
for (~SYM[13]=0;~SYM[13]<4;~SYM[13]=~SYM[13]+1) begin : ~GENSYM[mux_stage3][14]
  localparam n = 4;
  logic [7:0] i;
  assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:11] ~GENSYM[d][15];
genvar ~GENSYM[i4][16];
~GENERATE
for (~SYM[16]=0;~SYM[16]<2;~SYM[16]=~SYM[16]+1) begin : ~GENSYM[mux_stage4][17]
  localparam n = 5;
  logic [9:0] i;
  assign i = ~SYM[12][~SYM[16]*10:~SYM[16]*10+9];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:6] ~GENSYM[res][7];
~GENERATE
if (1) begin
localparam n = 6;
logic [11:0] i;
assign i = ~SYM[15][0:11];
always_comb begin
  case (i[n-1+n])
    1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE
~ELSE
logic [0:31] ~SYM[1];
assign ~SYM[1] = ~ARG[0][31:0];

logic [0:31] ~SYM[2];
genvar ~SYM[3];
~GENERATE
for (~SYM[3]=0;~SYM[3]<16;~SYM[3]=~SYM[3]+1) begin : ~SYM[8]
  assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
end
~ENDGENERATE

logic [0:23] ~SYM[4];
genvar ~SYM[5];
~GENERATE
for (~SYM[5]=0;~SYM[5]<8;~SYM[5]=~SYM[5]+1) begin : ~SYM[6]
  localparam n = 2;
  logic [3:0] i;
  assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:15] ~SYM[9];
genvar ~SYM[10];
~GENERATE
for (~SYM[10]=0;~SYM[10]<4;~SYM[10]=~SYM[10]+1) begin : ~SYM[11]
  localparam n = 3;
  logic [5:0] i;
  assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:9] ~SYM[12];
genvar ~SYM[13];
~GENERATE
for (~SYM[13]=0;~SYM[13]<2;~SYM[13]=~SYM[13]+1) begin : ~SYM[14]
  localparam n = 4;
  logic [7:0] i;
  assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:5] ~SYM[7];
~GENERATE
if (1) begin
localparam n = 5;
logic [9:0] i;
assign i = ~SYM[12][0:9];
always_comb begin
  case (i[n-1+n])
    1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE
~FI
assign ~RESULT = $unsigned(~SYM[7]);
// clz end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz8#"
    , "kind"      : "Declaration"
    , "type"      : "ctz8 :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "enc"
        , "extension" : "inc"
        , "template" :
"function [1:0] ~INCLUDENAME[0];
  input [1:0] a;
  case (a)
    2'b00:   ~INCLUDENAME[0] = 2'b10;
    2'b01:   ~INCLUDENAME[0] = 2'b01;
    2'b10:   ~INCLUDENAME[0] = 2'b00;
    default: ~INCLUDENAME[0] = 2'b00;
  endcase
endfunction"
        }
      ]
    , "template" :
"// ctz8 begin
logic [0:7] ~GENSYM[v][1];
genvar ~GENSYM[k][18];
~GENERATE
for (~SYM[18]=0;~SYM[18]<8;~SYM[18]=~SYM[18]+1) begin : ~GENSYM[reverse][19]
  assign ~SYM[1][~SYM[18]] = ~ARG[0][~SYM[18]];
end
~ENDGENERATE

logic [0:7] ~GENSYM[e][2];
genvar ~GENSYM[i][3];
~GENERATE
for (~SYM[3]=0;~SYM[3]<4;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
  assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
end
~ENDGENERATE

logic [0:5] ~GENSYM[a][4];
genvar ~GENSYM[i1][5];
~GENERATE
for (~SYM[5]=0;~SYM[5]<2;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
  localparam n = 2;
  logic [3:0] i;
  assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:3] ~GENSYM[res][7];
~GENERATE
if (1) begin
localparam n = 3;
logic [5:0] i;
assign i = ~SYM[4][0:5];
always_comb begin
  case (i[n-1+n])
    1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(~SYM[7]);
// ctz8 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz16#"
    , "kind"      : "Declaration"
    , "type"      : "ctz16 :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "enc"
        , "extension" : "inc"
        , "template" :
"function [1:0] ~INCLUDENAME[0];
  input [1:0] a;
  case (a)
    2'b00:   ~INCLUDENAME[0] = 2'b10;
    2'b01:   ~INCLUDENAME[0] = 2'b01;
    2'b10:   ~INCLUDENAME[0] = 2'b00;
    default: ~INCLUDENAME[0] = 2'b00;
  endcase
endfunction"
        }
      ]
    , "template" :
"// ctz16 begin
logic [0:15] ~GENSYM[v][1];
genvar ~GENSYM[k][18];
~GENERATE
for (~SYM[18]=0;~SYM[18]<16;~SYM[18]=~SYM[18]+1) begin : ~GENSYM[reverse][19]
  assign ~SYM[1][~SYM[18]] = ~ARG[0][~SYM[18]];
end
~ENDGENERATE

logic [0:15] ~GENSYM[e][2];
genvar ~GENSYM[i][3];
~GENERATE
for (~SYM[3]=0;~SYM[3]<8;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
  assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
end
~ENDGENERATE

logic [0:11] ~GENSYM[a][4];
genvar ~GENSYM[i1][5];
~GENERATE
for (~SYM[5]=0;~SYM[5]<4;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
  localparam n = 2;
  logic [3:0] i;
  assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:7] ~GENSYM[b][9];
genvar ~GENSYM[i2][10];
~GENERATE
for (~SYM[10]=0;~SYM[10]<2;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
  localparam n = 3;
  logic [5:0] i;
  assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:4] ~GENSYM[res][7];
~GENERATE
if (1) begin
localparam n = 4;
logic [7:0] i;
assign i = ~SYM[9][0:7];
always_comb begin
  case (i[n-1+n])
    1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(~SYM[7]);
// ctz16 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz32#"
    , "kind"      : "Declaration"
    , "type"      : "ctz32 :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "enc"
        , "extension" : "inc"
        , "template" :
"function [1:0] ~INCLUDENAME[0];
  input [1:0] a;
  case (a)
    2'b00:   ~INCLUDENAME[0] = 2'b10;
    2'b01:   ~INCLUDENAME[0] = 2'b01;
    2'b10:   ~INCLUDENAME[0] = 2'b00;
    default: ~INCLUDENAME[0] = 2'b00;
  endcase
endfunction"
        }
      ]
    , "template" :
"// ctz32 begin
logic [0:31] ~GENSYM[v][1];
genvar ~GENSYM[k][18];
~GENERATE
for (~SYM[18]=0;~SYM[18]<32;~SYM[18]=~SYM[18]+1) begin : ~GENSYM[reverse][19]
  assign ~SYM[1][~SYM[18]] = ~ARG[0][~SYM[18]];
end
~ENDGENERATE

logic [0:31] ~GENSYM[e][2];
genvar ~GENSYM[i][3];
~GENERATE
for (~SYM[3]=0;~SYM[3]<16;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
  assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
end
~ENDGENERATE

logic [0:23] ~GENSYM[a][4];
genvar ~GENSYM[i1][5];
~GENERATE
for (~SYM[5]=0;~SYM[5]<8;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
  localparam n = 2;
  logic [3:0] i;
  assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:15] ~GENSYM[b][9];
genvar ~GENSYM[i2][10];
~GENERATE
for (~SYM[10]=0;~SYM[10]<4;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
  localparam n = 3;
  logic [5:0] i;
  assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:9] ~GENSYM[c][12];
genvar ~GENSYM[i3][13];
~GENERATE
for (~SYM[13]=0;~SYM[13]<2;~SYM[13]=~SYM[13]+1) begin : ~GENSYM[mux_stage3][14]
  localparam n = 4;
  logic [7:0] i;
  assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:5] ~GENSYM[res][7];
~GENERATE
if (1) begin
localparam n = 5;
logic [9:0] i;
assign i = ~SYM[12][0:9];
always_comb begin
  case (i[n-1+n])
    1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(~SYM[7]);
// ctz32 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz64#"
    , "kind"      : "Declaration"
    , "type"      : "ctz64 :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "enc"
        , "extension" : "inc"
        , "template" :
"function [1:0] ~INCLUDENAME[0];
  input [1:0] a;
  case (a)
    2'b00:   ~INCLUDENAME[0] = 2'b10;
    2'b01:   ~INCLUDENAME[0] = 2'b01;
    2'b10:   ~INCLUDENAME[0] = 2'b00;
    default: ~INCLUDENAME[0] = 2'b00;
  endcase
endfunction"
        }
      ]
    , "template" :
"// ctz64 begin
logic [0:63] ~GENSYM[v][1];
genvar ~GENSYM[k][18];
~GENERATE
for (~SYM[18]=0;~SYM[18]<64;~SYM[18]=~SYM[18]+1) begin : ~GENSYM[reverse][19]
  assign ~SYM[1][~SYM[18]] = ~ARG[0][~SYM[18]];
end
~ENDGENERATE

logic [0:63] ~GENSYM[e][2];
genvar ~GENSYM[i][3];
~GENERATE
for (~SYM[3]=0;~SYM[3]<32;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
  assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
end
~ENDGENERATE

logic [0:47] a;
genvar ~GENSYM[i1][5];
~GENERATE
for (~SYM[5]=0;~SYM[5]<16;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
  localparam n = 2;
  logic [3:0] i;
  assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:31] ~GENSYM[b][9];
genvar ~GENSYM[i2][10];
~GENERATE
for (~SYM[10]=0;~SYM[10]<8;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
  localparam n = 3;
  logic [5:0] i;
  assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:19] ~GENSYM[c][12];
genvar ~GENSYM[i3][13];
~GENERATE
for (~SYM[13]=0;~SYM[13]<4;~SYM[13]=~SYM[13]+1) begin : ~GENSYM[mux_stage3][14]
  localparam n = 4;
  logic [7:0] i;
  assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:11] ~GENSYM[d][15];
genvar ~GENSYM[i4][16];
~GENERATE
for (~SYM[16]=0;~SYM[16]<2;~SYM[16]=~SYM[16]+1) begin : ~GENSYM[mux_stage4][17]
  localparam n = 5;
  logic [9:0] i;
  assign i = ~SYM[12][~SYM[16]*10:~SYM[16]*10+9];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:6] ~GENSYM[res][7];
~GENERATE
if (1) begin
localparam n = 6;
logic [11:0] i;
assign i = ~SYM[15][0:11];
always_comb begin
  case (i[n-1+n])
    1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE

assign ~RESULT = $unsigned(~SYM[7]);
// ctz64 end"
    }
  }
, { "BlackBox" :
    { "name"      : "GHC.Prim.ctz#"
    , "kind"      : "Declaration"
    , "type"      : "ctz :: Word# -> Word#"
    , "imports"   : ["~INCLUDENAME[0].inc"]
    , "includes" :
      [ { "name" : "enc"
        , "extension" : "inc"
        , "template" :
"function [1:0] ~INCLUDENAME[0];
  input [1:0] a;
  case (a)
    2'b00:   ~INCLUDENAME[0] = 2'b10;
    2'b01:   ~INCLUDENAME[0] = 2'b01;
    2'b10:   ~INCLUDENAME[0] = 2'b00;
    default: ~INCLUDENAME[0] = 2'b00;
  endcase
endfunction"
        }
      ]
    , "template" :
"// ctz begin
~IF ~IW64 ~THEN
logic [0:63] ~GENSYM[v][1];
genvar ~GENSYM[k][18];
~GENERATE
for (~SYM[18]=0;~SYM[18]<64;~SYM[18]=~SYM[18]+1) begin : ~GENSYM[reverse][19]
  assign ~SYM[1][~SYM[18]] = ~ARG[0][~SYM[18]];
end
~ENDGENERATE

logic [0:63] ~GENSYM[e][2];
genvar ~GENSYM[i][3];
~GENERATE
for (~SYM[3]=0;~SYM[3]<32;~SYM[3]=~SYM[3]+1) begin : ~GENSYM[enc_stage][8]
  assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
end
~ENDGENERATE

logic [0:47] ~GENSYM[a][4];
genvar ~GENSYM[i1][5];
~GENERATE
for (~SYM[5]=0;~SYM[5]<16;~SYM[5]=~SYM[5]+1) begin : ~GENSYM[mux_stage][6]
  localparam n = 2;
  logic [3:0] i;
  assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:31] ~GENSYM[b][9];
genvar ~GENSYM[i2][10];
~GENERATE
for (~SYM[10]=0;~SYM[10]<8;~SYM[10]=~SYM[10]+1) begin : ~GENSYM[mux_stage2][11]
  localparam n = 3;
  logic [5:0] i;
  assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:19] ~GENSYM[c][12];
genvar ~GENSYM[i3][13];
~GENERATE
for (~SYM[13]=0;~SYM[13]<4;~SYM[13]=~SYM[13]+1) begin : ~GENSYM[mux_stage3][14]
  localparam n = 4;
  logic [7:0] i;
  assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:11] ~GENSYM[d][15];
genvar ~GENSYM[i4][16];
~GENERATE
for (~SYM[16]=0;~SYM[16]<2;~SYM[16]=~SYM[16]+1) begin : ~GENSYM[mux_stage4][17]
  localparam n = 5;
  logic [9:0] i;
  assign i = ~SYM[12][~SYM[16]*10:~SYM[16]*10+9];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[15][~SYM[16]*6:~SYM[16]*6+5] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:6] ~GENSYM[res][7];
~GENERATE
if (1) begin
localparam n = 6;
logic [11:0] i;
assign i = ~SYM[15][0:11];
always_comb begin
  case (i[n-1+n])
    1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE
~ELSE
logic [0:31] ~SYM[1];
genvar ~SYM[18];
~GENERATE
for (~SYM[18]=0;~SYM[18]<32;~SYM[18]=~SYM[18]+1) begin : ~SYM[19]
  assign ~SYM[1][~SYM[18]] = ~ARG[0][~SYM[18]];
end
~ENDGENERATE

logic [0:31] ~SYM[2];
genvar ~SYM[3];
~GENERATE
for (~SYM[3]=0;~SYM[3]<16;~SYM[3]=~SYM[3]+1) begin : ~SYM[8]
  assign ~SYM[2][~SYM[3]*2:~SYM[3]*2+1] = ~INCLUDENAME[0](~SYM[1][~SYM[3]*2:~SYM[3]*2+1]);
end
~ENDGENERATE

logic [0:23] ~SYM[4];
genvar ~SYM[5];
~GENERATE
for (~SYM[5]=0;~SYM[5]<8;~SYM[5]=~SYM[5]+1) begin : ~SYM[6]
  localparam n = 2;
  logic [3:0] i;
  assign i = ~SYM[2][~SYM[5]*4:~SYM[5]*4+3];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[4][~SYM[5]*3:~SYM[5]*3+2] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:15] ~SYM[9];
genvar ~SYM[10];
~GENERATE
for (~SYM[10]=0;~SYM[10]<4;~SYM[10]=~SYM[10]+1) begin : ~SYM[11]
  localparam n = 3;
  logic [5:0] i;
  assign i = ~SYM[4][~SYM[10]*6:~SYM[10]*6+5];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[9][~SYM[10]*4:~SYM[10]*4+3] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:9] ~SYM[12];
genvar ~SYM[13];
~GENERATE
for (~SYM[13]=0;~SYM[13]<2;~SYM[13]=~SYM[13]+1) begin : ~SYM[14]
  localparam n = 4;
  logic [7:0] i;
  assign i = ~SYM[9][~SYM[13]*8:~SYM[13]*8+7];
  always_comb begin
    case (i[n-1+n])
      1'b0    : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
      default : ~SYM[12][~SYM[13]*5:~SYM[13]*5+4] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
    endcase
  end
end
~ENDGENERATE

logic [0:5] ~SYM[7];
~GENERATE
if (1) begin
localparam n = 5;
logic [9:0] i;
assign i = ~SYM[12][0:9];
always_comb begin
  case (i[n-1+n])
    1'b0    : ~SYM[7] = {i[n-1+n] && i[n-1],1'b0,i[2*n-2:n]};
    default : ~SYM[7] = {i[n-1+n] && i[n-1],~ i[n-1],i[n-2:0]};
  endcase
end
end
~ENDGENERATE
~FI
assign ~RESULT = $unsigned(~SYM[7]);
// ctz end"
    }
  }
]
